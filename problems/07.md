# Building Append-Only Data Structures

In the previous exercises we've build out a simple query system that can query our ever growing stats log efficiently.
However by adding something we call "embedded indexes" to our log we can actually make it much faster.

Embedded indexes are small amount of information we add to each log entry that acts as routing info to find entries before it as efficiently as possible. In the previous excercises each stats log entry did not tell anything about the entries before it, and only because the data is "time ordered", could we query it by bisecting the log.

Embedded indexes can be tricky to write as they have to be small enough to not take up too much space in the log entry but also be powerful enough to support finding what you are looking for efficiently. In some of the future exercises we'll look at data structures that have powerful embedded indexes that allows us to quickly find generic string keys in the log but now we are getting a bit ahead of our self.

## Exercises

Let's update our stats collector so it uses an embedded index to make it faster to find entries.

An embedded index for our log could look like this:

```js
{
  index: [
    { timestamp: Date, blockIndex: blockIndex - 1 },
    { timestamp: Date, blockIndex: blockIndex - 2 },
    { timestamp: Date, blockIndex: blockIndex - 4 },
    { timestamp: Date, blockIndex: blockIndex - 8 },
    ...
  ],
  stats: <the stats object>
}
```

Each entry in the index would contain the timestamp for a block and the corresponding block index for it.

By including the timestamps for the blocks at `index - 1`, `index - 2`, `index - 4`, ... `index - 2^n`, where `index - 2^n >= 0` it makes finding the first block larger or equal to a specific timestamp easier and faster.

To do this we only need use the following algorithm:

```js
// Returns the index of the closest block using the index above.
// If the entry passed in is the closest it will return -1.
function closestBlock (timestamp, block) {
  // No index -> no closer block
  if (!block.index.length) return -1

  for (let i = 0; i < block.index.length; i++) {
    // If block is too old, the previous one must be closest
    if (block.index[i].timestamp < timestamp) {
      // First block (block.blockIndex - 1) is too old - block is closests
      if (i === 0) return -1
      // Otherwise the previous index block is closest
      return block.index[i - 1].blockIndex
    }
  }

  // Oldest one is closest
  return block.index[block.index.length - 1].blockIndex
}
```

To find the first entry larger than a specific timestamp we just need to use the `closestBlock` function from above.

1. First load the latest block.
2. Check if any block is closer using the `closestBlock` algorithm.
3. If so load that block and reuse the `closestsBlock` algorithm on and see 2.

To generate the index we on the writer can use the following algorithm:

```js
const index = []

let distance = 1
let nextBlockIndex = feed.length

while (nextBlockIndex - distance >= 0) {
  const blockIndex = nextBlockIndex - distance
  const block = await core.get(blockIndex)

  index.push({
    timestamp: block.stats.timestamp,
    blockIndex
  })

  distance *= 2
}
```

#### Exercise 1

Update the stats collector writer to add the embedded index using the technique above.
To verify it, update your reader to use the embedded index to find specific blocks close to a timestamp.

[Once your embedded index log is working continue to Problem 8](08.md)
