## Querying with Hyperbee -- Secondary Indexing
In the previous exercise, we learned how to query for a range of dictionary entries, sorted by their names. Since the name is the primary key, we can use it in range queries efficiently. Searching for definitions according to some other property, such as the definition's length, is still possible, but it would require scanning the entire database, because the key does not tell us anything about the definition.

## Exercises

Here we're going to search for dictionary entries that have a given length. Our current dictionary database isn't going to be well-suited for this, but let's try anyway. In Exercise 2, we'll see how the database can be extended to make these kinds of queries fast (hint: it will require adding a lot more keys).

We'll be extending the work you did in Problem 11 here.

#### Exercise 1

Let's try to find all definitions with a character length of 35, using the database from the previous exercise:

```js
async function findDefinitionsWithLength (length) {
  const matches = []
  for await (const result of db.createReadStream()) {
    if (result.value.length === length) matches.push(result)
  }
}
```

This is a pretty bad solution for a number of reasons! Not only is it slow, but every single reader of our database is going to have to do this full scan themselves, each time they want to run the query. Sure, the database will be cached locally after the first scan, so the bandwidth/latency cost will only be incurred once, but even locally this is far slower than it needs to be.

#### Exercise 2

What if instead of putting the burden on the reader to scan the full database, the writer did the complete scan once, then added additional kv-pairs to the database? These additional pairs could sort in a way that makes the definition length query fast. This is called "secondary indexing".

Generate a secondary index on definition lengths by iterating over the entire database, and for each entry inserting a kv-pair of the form:
```js
    length/name -> definition
```

As an example, if you come across the record `dog -> 'A four-legged animal'`, you'll want to create the new entry `20/dog -> 'A four-legged animal'`. You'll be duplicating definitions, but that's just fine.

As with the previous exercise, you'll probably want to speed this up by using the `batch` method.

Once the secondary index has been created, try answering the following queries (they should be almost instantaneous!):
1. 

If you aren't sure how to translate those queries into `createReadStream` options, expand the hint below.

<details>
    <summary>Query Options</summary>


</details>

#### Bonus Exercise

In the previous exercise you duplicated the definitions in the secondary index. Try storing a pointer to the original entry instead, to save some space. Try imagining how many network requests a reader will need to do to answer a query, both with and without this indirection.


* The problem here is that every user is going to have to do this scan themselves, every time they want to find definitions that have a specific length. We can spare them the trouble by instead creating a second key for each entry that is the concatenation of the definition's length and name (`length/name`). This pattern is called "secondary indexing". By using `length/name`, a user can perform the query `createReadStream({ gt: `100/`, limit: 1 })` to find the first word with a definition of 100 characters.

#### Exercises
 * Extending the previous example, insert a second key for each dictionary entry of the form `(definition length)/(word) -> definition`.
 * After you've created this secondary index, test it by querying for all definitions that satisfy the following conditions:
     * "All definitions with length 36" (there should be N)
     * "All definitions with length 45 that start with 'b'" (there should be M)
     * "The first 10 definitions with length 22" (there should be P)
* (Bonus) So far, you've been duplicating values in the secondary index. Try fixing this by storing a pointer to the primary entry instead.

[Continue to problem 13](13.md)
