## Querying with Hyperbee -- Indexing
In the previous exercise, we learned how to query for a range of dictionary entries, sorted by their names. Since the name is the primary key, we can use it in range queries efficiently. Searching for definitions according to some other property, such as the definition's length, is still possible, but it would require scanning the entire database, because the key does not tell us anything about the definition.

## Exercises

Here we're going to search for dictionary entries that have a given length. Our current dictionary database isn't going to be well-suited for this, but let's try anyway. In Exercise 2, we'll see how the database can be extended to make these kinds of queries fast (hint: it will require adding a lot more keys).

We'll be extending the work you did in Problem 11 here.

#### Exercise 1
Let's try to find all definitions with a character length of 35, using the database from the previous exercise:

```js
async function findDefinitionsWithLength (length) {
  const matches = []
  for await (const result of db.createReadStream()) {
    if (result.value.length === length) matches.push(result)
  }
}
```
* The problem here is that every user is going to have to do this scan themselves, every time they want to find definitions that have a specific length. We can spare them the trouble by instead creating a second key for each entry that is the concatenation of the definition's length and name (`length/name`). This pattern is called "secondary indexing". By using `length/name`, a user can perform the query `createReadStream({ gt: `100/`, limit: 1 })` to find the first word with a definition of 100 characters.

#### Exercises
 * Extending the previous example, insert a second key for each dictionary entry of the form `(definition length)/(word) -> definition`.
 * After you've created this secondary index, test it by querying for all definitions that satisfy the following conditions:
     * "All definitions with length 36" (there should be N)
     * "All definitions with length 45 that start with 'b'" (there should be M)
     * "The first 10 definitions with length 22" (there should be P)
* (Bonus) So far, you've been duplicating values in the secondary index. Try fixing this by storing a pointer to the primary entry instead.

[Continue to problem 13](13.md)
