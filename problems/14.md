## Querying a Real-World P2P Database (IMDB)

Great job making it this far! Hopefully you are a little more familiar with keyEncodings now and how to make and query custom indexes.
To test our learnings against a real world dataset, we've inserted the [entire IMDB dataset](https://www.imdb.com/interfaces/), along with a couple of secondary indexes for ratings and keywords, into a Hyperbee.

The database is available as this public key:

```
de99028939d93fede2a58223a4c23364225ae324dd5739054d573b8726bc0e9d
```

This IMDB Hyperbee database contains three indexes.

One for the title ids:

```
ids!{imdbTitleId} -> metadataObject
```

An example title id is `tt8760684`. You can find your own by looking in the URL when looking at a movie or tv show on https://imdb.com.
The `metadataObject` is a JSON object containing stuff like the name of the movie, the rating, the genre, and more.

Another one for the entry ratings:

```
ratings!{lexint.pack(10 * rating, 'hex')}!${lexint.pack(ratingVotes, 'hex')}!${imdbTitleId} -> imdbTitleId
```

This one rank all entries by rating.
For example the title linked above, `tt8760684`, has a rating of `8.2` with `20736` votes. That means it's entry in this index looks like this:

```
ratings!{lexint.pack(82, 'hex')}!${lexint.pack(82, 'hex')}!tt8760684 === ratings!52!fc5005!tt8760684
```

Finally there is one for title keywords, that looks like this:

```
keywords!{keyword.toLowerCase()}!lexint.pack(10 * rating, 'hex')!${imdbTitleId} -> imdbTitleId
```

For example the entry for "Game of Thrones" would have three keywords, `['game', 'of', 'thrones']`.

# Exercises

#### Exercise 1

Use the replicate method and the above public key to make a Hyperbee instance that replicates the remote IMDB dataset.
Make sure to set the valueEncoding for the Hyperbee itself to `json` as the values here are stored as JSON.

To test it try querying for:

```
ids!tt8760684
```

And see that it returns the correct result.

#### Exercise 2

Use the ratings index to find the 10 highest rated entries in the dataset.
Also use it to find the 10 lowest rated ones.

#### Exercise 3

Using the keyword index we can make a simple search API for the dataset to find entries.

Implement a function called `search(keyword)` that searches the keyword index for results containing a specific keyword by returning the result stream.

Since we include the rating in this index as well, you can use the `reverse` option to rank the search results by IMDB rating.

#### Bonus Exercise 4

Normally for a search you would want to filter results based on multiple keywords, or potentially return the "sum" of the results.

Since search method above returns a result stream that is sorted we can actually combine multiple result streams by using a streaming union or streaming intersection algorithm.

To due a union we can use the module [sorted-union-stream](https://github.com/mafintosh/sorted-union-stream) and to due an intersection we can use [sorted-intersect-stream](https://github.com/mafintosh/sorted-intersect-stream).

To make a union of two results stream we just need to do:

```js
const union = require('sorted-union-stream')

const resultA = search('keyword1')
const resultB = search('keyword2')

const unionResult = union(resultA, result2, function (a, b) {
  if (a.key < b.key) return -1
  if (a.key > b.key) return 1
  return 0
})
```

Use the above technique to make a `searchUnion([keyword1, keyword2])` and `searchIntersection([keyword1, keyword2])` API.
Try searching for the intersection of ["game", "thrones"] or something similar to see that it works.

[When you are done playing with querying the IMDB dataset, continue to Problem 15, the last problem](15.md)
