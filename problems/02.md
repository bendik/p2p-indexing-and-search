# Intro to Append-Only Logs
Before we can get to databases, we first need to cover the fundamentals of "append-only logs". We'll be referring to these logs a ton throughout the workshop, so these next exercises will help familiarize you with the basics.

### Hypercore is a Secure Append-Only Log
An append-only log is a super simple data structure: it's pretty much an array that only supports `push`. You can push elements into it, get the element at a specific location, and that's about it.

At a glance, this would appear useless outside of simple use-cases such as logging. But if you take a closer look, the immutability of an append-only log affords many benefits:
1. The log is "versioned" by default. Since nothing is deleted, you can explore the complete history of the log at any point in time.
2. The ordering of a log's elements never changes. This means that you can refer back to any previous state in its history using the log's length as a stable identifier (i.e. the state at length 7).
3. It's easy to cache. If you share a log with somebody, and they download first 10 items, those 10 items will never change in the future.

In the context of peer-to-peer systems, these properties turn out to be especially useful. We can take advantage of a log's immutability to construct "proofs" about it's state, and we can use those proofs to design an efficient and secure system for sharing, or "replicating", the log with others. Hypercore, the foundational module in our ecosystem, is just an append-only log implementation with some added machinery for working with these proofs -- we call it a "secure append-only log".

### Sharing Hypercores

In Hypercore, we introduce the idea of "writers" and "readers". A Hypercore can only be appended to by its original creator, the writer. The writer maintains a private key which they use to sign a new proof each time data is appended to the Hypercore. When sharing the Hypercore with readers, the writer sends along proofs as well, so that the reader can verify that the Hypercore hasn't been tampered with.

Since proofs are distributed widely among all readers, a powerful feature emerges: Readers can share Hypercores with other readers, without needing to involve the writer at all -- they just need to re-send the proofs they were given by the writer! This is great for P2P systems. It keeps things resilient, because readers can keep the Hypercore available even after the writer goes offline, and it enables "bandwidth sharing", because readers can share the burden of distribution. 

If you're familiar with BitTorrent, this all might sound familiar. Hypercore shares many features with BitTorrent, but since append-only logs can be appended to, 

The writer's public key is used as a unique identifier for the Hypercore

### The Hypercore Way
We won't go into the details of Hypercore's internals here, but if you're curious, check out [our website](https://hypercore-protocol.org) or [the Hypercore repo](https://github.com/hypercore-protocol/hypercore).


### Hyperspace Makes Hypercore Easier

## Exercises

Hyperspace exposes append-only logs through the corestore interface.

```js
const store = c.corestore()

// Feed is a hypercore instance, which is an append-only log
const feed = store.get({ name: 'exercise-03 '})

// Wait for internal state to load
await feed.ready()

console.log(feed) // Prints out details like the length of the log, byteLength, the public key etc.
```

#### Exercise 1

Run the above to see that you access a feed and print out info about it.
It should print something similar to

```js
{
  ...
  key: deadb...eef,
  peer: 0,
  length: 0,
  byteLength: 0,
}
```

#### Exercise 2

To interact with an append-only log there are four core concepts.

* Knowing what the public key of the log is so you can share it with other people.
* Appending a new block of data to the log (`feed.append`).
* Getting a block of data from an index (`feed.get`).
* Knowing how many blocks of data are in the log (`feed.length`).

To append a block of data the Hypercore feed exposes the append method.

```js
await feed.append('block #' + feed.length)
```

Append a block of data to the feed above.
Everytime you append you should see the `length` increase by one when printing it out.

#### Exercise 3

Now that we know how to append data and check how many blocks of data are in the feed,
make a for loop that prints out all the data in the feed.

You can use `block = await feed.get(index)` to get a specific block of data out.

Make a for loop that prints out each block of data from the feed.

```js
for (let i = 0; i < feed.length; i++) {
  // print the block stored at i
}
```

Notice that the `feed.get` api returns the block as a Node.js buffer.
If you want to turn that into a string you need to do `block.toString()` or do
`feed.get(index, { valueEncoding: 'utf-8' })`

If your solution works it should print something like:

```
block #0
block #1
block #2
...
```

Now that we have a better idea on how to interact with append-only logs locally we can [continue to problem 03](03.md)
