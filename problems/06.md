## Query a Large Dataset (No Embedded Index)
Let's see how well your algorithm works on a really big dataset! In the previous example, we were syncing between two peers on the same machine for testing purposes. That was useful for testing our the algorithms, but it obscured how the algorithms perform in real-world scenarios.

We've been collecting a bunch of process stats on our server somewhere in Germany. In the next exercise, we'll run the algorithms we built in Exercise 5 against this real-world dataset. 

*Note: Once people in the workshop start playing with this core, subsequent participants will start swarming with them. This is a good thing, but it does mean that if you're late to the party, you might see lower latencies all-around in this exercise (by connecting to closer peers)*

## Exercise

Here's the key to our big Hypercore, sitting somewhere in Germany: 

__Stats Hypercore Key: 309ba1736cc5af2940fc9fb03d256547b78ca9972ce4398648a7d7782d31ad4b__

## Takeaways
Using the naive approach, the reader needs to download the entire log, even though they're only interested in one block. It works, but it's slow and bandwidth-intensive, especially on large datasets. On the plus side, after the query the reader has downloaded a complete replica of the log, which means the dataset will remain fully available if the writer goes offline.

But we can do a lot better by taking advantage of the fact that the data is time-ordered, or "indexed by time". 

[In Problem 7, we'll put time to use](07.md)